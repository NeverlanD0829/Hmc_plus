//正对面向对象编程做详细讲解。他探讨c++核心和精髓

// 内存分区模型
// 代码区：存放函数的二级制代码，由操作系统进行管理的
// 全局区：存放全局变量和静态变量以及常量
// 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
// 堆区： 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
// 内存四区意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

// 程序运行前
// 在程序编译后，生成了exe可执行文件，未执行该程序前分为两个区域。

// 代码区：

// 存放cpu执行的机器指令
// 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份打码即可
// 代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令
//（就是存放你的程序的编译后的可执行二进制代码，CPU执行的机器指令，并且是只读的。存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）。）

// 全局区：

// 全局变量和静态变量存放于此
// 全局区还包含了常量区，字符串常量和其他常量也存放于此
// 该区域的数据在程序结束之后由操作系统释放
// 该区域的数据在程序结束后由操作系统释放

//全局区比较特殊，里面还分成了全局变量区，静态变量区，常量区。全局变量区用来存放全局变量，静态变量区用来存放带有static修饰的变量（包括静态局部变量和静态全局变量），只要含有static就存在这个区。
//常量区是用来存放字符常量的，还有const修饰的全局变量的，const 修饰的局部变量不存在这里，别搞混了。
//全局区存放的一切都是由操作系统管理，等程序结束由操作系统释放。常量区里存放的数据不可更改，就算你用指针也不行，你可能会说const修饰的局部变量都可以用指针改，但是局部变量可不是存放在常量区，这点搞清楚。

//以上四区，代码区和全局区在生成.exe文件后就有了，双击.exe运行程序才会生成堆区和栈区。
#include<iostream>
#include<string>
using namespace std;


//全局变量
int g_a=10;
int g_b=10;


//const修饰的全局常量
const int c_g_a=10;

int main()
{
    //局部变量
    int a=10;
    int b=10;



    //静态变量（普通变量前加static）        和全局变量放在一个区
    static int s_a=10;

    //常量
    //字符串常量


    //const修饰常量
    //const修饰的局部常量
    const int c_l_b=10;   //c-const  l-local g-global




    cout<<"局部变量a的地址为:"<<&a<<endl;
    cout<<"局部变量b的地址为:"<<&b<<endl;

    cout<<"全局变量g_a的地址为:"<<&g_a<<endl;
    cout<<"全局变量g_b的地址为:"<<&g_b<<endl;

    cout<<"静态变量g_b的地址为:"<<&s_a<<endl;

    cout<<"字符串常量的地址为:"<<&"hello_world"<<endl;


    cout<<"const修饰的全局常量的地址为:"<<&c_g_a<<endl;
    cout<<"const修饰的局部常量的地址为:"<<&c_l_b<<endl;



    system("pause");
    return 0;
}


//总结：局部变量、const修饰的局部变量不在常量区。
//全局变量，静态变量，字符串常量，const修饰的全局变量（全局常量）放在全局区。