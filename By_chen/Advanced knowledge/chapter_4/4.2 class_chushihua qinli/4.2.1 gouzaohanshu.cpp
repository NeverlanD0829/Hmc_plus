// C++利用构造函数和析构函数解决了对象的初始化和清理。
//对象的初始化和清理工作是编译器强制要求我们做的事情，因此就算我们不提供构造(初始化)和析构（清理），编译器也会提供，只不过编译器提供的是  构造函数  和  析构函数  的空实现。

//构造函数（创建对象时为对象的成员属性赋值）：    类名（）{}
    //1、构造函数没有返回值，也不写void；
    //2、函数名称与类名相同；
    //3、构造函数可以有参数，因此可以发生重载；
    //4、程序在调用对象会自动调用构造，无需手动调用，且只会调用一次。



//析构函数（作用在对象销毁前系统自动调用，执行清理作用）：    ~ 类名（）{}
    //1、构造函数没有返回值，也不写void；
    //2、函数名称与类名相同，在名称前加上~；
    //3、析构函数不可以有参数，不可以发生重载；
    //4、程序在对象销毁前会自动调用析构，无需手动调用，且只会调用一次。


#include<iostream>
using namespace std;
const double PI=3.14;

class Person
{
    public:
        Person()                                    //构造函数，函数名称与类名相同，可以有参数，可以重载。   调用对象时会自动构造，无需调用，且只会调用一次。
        {
            cout<<"Person 构造函数的调用"<<endl;
        }

        ~Person()                                    //析构函数，对象销毁前会自动调用析构，无需手动调用，且只会调用一次，不可以有参数，不可以重载。
        {
            cout<<"Person 析构函数的调用"<<endl;
        }
};


//注意：构造和析构函数都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构。


void test01()
{
    Person p;                           //栈上的数据，test01执行完后，释放该对象。//只创建对象，没有调用构造函数（p后没有括号），但是程序可运行，系统自动调用函数。

}

int main()
{
    Person p;                            //若是在main函数中直接实例化Person，则不会调用析构函数，因为由于system("pause");的存在，main函数未执行完，到此就中断了

    test01();                           //test01调用完成后，会自动调用析构函数清理内存

    system("pause");
    return 0;
}